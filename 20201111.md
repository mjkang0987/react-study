**20201109-섹션5.랜더링 속도를 올리기 위한 성능 최적화 방법1**

## 리액트의 랜더링
- 리액트 실행될 때 가장 많은 CPU 작업이 필요한 부분이 랜더링이다.
- 리액트는 UI 라이브러리이기 때문에 실행되는 동안 화면을 그린다.

### 랜더링 순서 
- 데이터와 컴포넌트 함수로 화면을 그린다.
  - 대부분읭 연산은 컴포넌트 함수의 실행과 가상돔에서 발생한다.
  - 데이터는 컴포넌트의 속성값/상태값을 말한다.
- 속성값/상태값이 변경되면 자동으로 컴포넌트 함수를 이용해서 하면을 다시 그린다.

### 랜더링 필요 여부
- 랜더링 필요 여부를 판단하는 과정이 있다.
  - memo 함수 이용
    - 속성값 변경 사항이 없다면 이전 랜더링 결과 재사용
- 랜더링이 필요하다고 판단되면 컴포넌트 함수를 호출해서 새로운 가상돔읆 만들고, 이전 만들었던 가상돔과 비교해서 변경점을 찾는다.
- 변경된 부분을 실제 돔에 반영한다.

### 랜더링 속도 개선을 위해서 각 단계에서 우리가 할 수 있는 일
- 평상시에는 성능최적화 고민을 하지않고 편하게 코딩하는 것이 좋다.
- 대부분의 웹페이지는 성능을 고민하지 않고 코딩을 해도 문제없이 잘 돌아간다.
- 성능이슈 발생 시 고민해도 늦지않다.

### 랜더링 시점
- 컴포넌트의 속성값/상태값 변경 시 리액트는 컴포넌트를 다시 그릴 준비를 한다.

### memo 함수 
- memo 함수로 감싼 컴포넌트라면 속성값 비교 함수가 호출된다.
  - 이전/이후 속성값 매개변수로 받아서 참/거짓을 반환한다.
    - 참: 이전 랜더링 결과 재사용
    - 거짓: 컴포넌트 함수를 실행해서 가상돔을 업데이트 하고 변경된 부분만 실제 돔에 반영한다.
  - 속성값 비교 함수를 입력하지 않으면 얕은 비교를 수행하는 기본 함수가 사용된다.
  - 컴포넌트를 memo 함수로 감싸지 않았다면 항상 거짓을 반환하는 속성값 비교 함수가 사용된다고 생각할 수 있다.
    - 부모 컴포넌트가 랜더링 될 때 마다 자기 자신도 랜더링 된다.
    - 속성값 변경 함수가 거짓을 반환하더라도 실제의 속성값이 변경되지 않았다면 실제 돔도 변경되지 않는다.
  - 랜더링이 중요한 상황에서는 컴포넌트 함수의 실행과 가상돔의 계산을 생략할 수 있기때문에 성능상 이점이 있다.

#### 속성값 변경 여부 판단
- 상태값 객체를 불변 객체로 관리
  - 이전/이후 값 단순 비교로 컴포넌트 값 변경을 알 수 있다.
  - 랜더링 성능에 큰 도움이 된다.  
```jsx
prevProps.todos === nextProps.todos
```
```jsx
const todos = [1, 2, 3];
todos.push(4); // 불변객체로 관리하지 않을 경우
const nextTodos = [...todos, 4]; // 불변객체로 관리

todos === nextTodos; // 간단하게 이전 이후 값 비교 가능
```

#### 속성값 비교 함수 사용하지 않을 경우
- 리액트는 얕은 비교를 수행한다.
```jsx
const isEqual = prevProps.todos === nextProps.todos && prevProps.friends === nextProps.friends;
```