**20201111-섹션5.랜더링 속도를 올리기 위한 성능 최적화 방법1**

## 리액트의 랜더링
- 리액트 실행될 때 가장 많은 CPU 작업이 필요한 부분이 랜더링이다.
- 리액트는 UI 라이브러리이기 때문에 실행되는 동안 화면을 그린다.

### 랜더링 순서 
- 데이터와 컴포넌트 함수로 화면을 그린다.
  - 대부분읭 연산은 컴포넌트 함수의 실행과 가상돔에서 발생한다.
  - 데이터는 컴포넌트의 속성값/상태값을 말한다.
- 속성값/상태값이 변경되면 자동으로 컴포넌트 함수를 이용해서 하면을 다시 그린다.

### 랜더링 필요 여부
- 랜더링 필요 여부를 판단하는 과정이 있다.
  - memo 함수 이용
    - 속성값 변경 사항이 없다면 이전 랜더링 결과 재사용
- 랜더링이 필요하다고 판단되면 컴포넌트 함수를 호출해서 새로운 가상돔읆 만들고, 이전 만들었던 가상돔과 비교해서 변경점을 찾는다.
- 변경된 부분을 실제 돔에 반영한다.

### 랜더링 속도 개선을 위해서 각 단계에서 우리가 할 수 있는 일
- 평상시에는 성능최적화 고민을 하지않고 편하게 코딩하는 것이 좋다.
- 대부분의 웹페이지는 성능을 고민하지 않고 코딩을 해도 문제없이 잘 돌아간다.
- 성능이슈 발생 시 고민해도 늦지않다.

### 랜더링 시점
- 컴포넌트의 속성값/상태값 변경 시 리액트는 컴포넌트를 다시 그릴 준비를 한다.

### memo 함수 
- memo 함수로 감싼 컴포넌트라면 속성값 비교 함수가 호출된다.
  - 이전/이후 속성값 매개변수로 받아서 참/거짓을 반환한다.
    - 참: 이전 랜더링 결과 재사용
    - 거짓: 컴포넌트 함수를 실행해서 가상돔을 업데이트 하고 변경된 부분만 실제 돔에 반영한다.
  - 속성값 비교 함수를 입력하지 않으면 얕은 비교를 수행하는 기본 함수가 사용된다.
  - 컴포넌트를 memo 함수로 감싸지 않았다면 항상 거짓을 반환하는 속성값 비교 함수가 사용된다고 생각할 수 있다.
    - 부모 컴포넌트가 랜더링 될 때 마다 자기 자신도 랜더링 된다.
    - 속성값 변경 함수가 거짓을 반환하더라도 실제의 속성값이 변경되지 않았다면 실제 돔도 변경되지 않는다.
  - 랜더링이 중요한 상황에서는 컴포넌트 함수의 실행과 가상돔의 계산을 생략할 수 있기때문에 성능상 이점이 있다.

#### 속성값 변경 여부 판단
- 상태값 객체를 불변 객체로 관리
  - 이전/이후 값 단순 비교로 컴포넌트 값 변경을 알 수 있다.
  - 랜더링 성능에 큰 도움이 된다.  
```jsx
prevProps.todos === nextProps.todos
```
```jsx
const todos = [1, 2, 3];
todos.push(4); // 불변객체로 관리하지 않을 경우
const nextTodos = [...todos, 4]; // 불변객체로 관리

todos === nextTodos; // 간단하게 이전 이후 값 비교 가능
```

#### 속성값 비교 함수 사용하지 않을 경우
- 리액트는 얕은 비교를 수행한다.
```jsx
const isEqual = prevProps.todos === nextProps.todos && prevProps.friends === nextProps.friends;
```

### 컴포넌트 함수 내부에서 생성되는 함수와 객체
#### 함수
- 부모 컴포넌트가 상태값 변경에 의해 랜더링 할 때 자식 컴포넌트도 랜더링한다.
  - 자식 컴포넌트에 함수를 작성하면 랜더링 할 때 마다 새로운 값이 입력되므로 다시 랜더링이 된다.
```jsx
const [selectedFruit, setSelectedFruit] = useState('apple');
return (
  <div>
    <SelectedFruit
      selected={selectedFruit}
      onChange={fruit => setSelectFruit(fruit)} 
      // 함수를 작성하면 랜더링 할 때 마다 새로운 값이 입력되므로 다시 랜더링 된다.
    />
    <SelectedFruit
      selected={selectedFruit}
      onChange={setSelectedFruit} 
      // 지금과 같이 단순하게 상태값을 변경하는 로직이라면 상태값 변경 함수를 그대로 입력하면 해결된다.
      // 상태값 변경 함수는 한 번 생성되고 변경되지 않는다.
    />
  </div>
)
```
- 간단한 함수 외에 다른 처리가 필요하다면 `useCallback` hook을 사용한다.
  - 필요할때만 함수가 변경된다.
```jsx
const onChangeFruit = useCallback(() => {
  setSelectedFruit(fruit);
  sendLog({type: 'fruit change', value: fruit});
}, []); // 속성값이나 상태값이 사용되지 않았으므로 빈배열 입력 -> 한 번 생성된 값으로 고정이 된다. 
```
  
#### 객체
- 컴포넌트 내부에서 객체를 정의해서 자식 컴포넌트의 속성값으로 객체를 정의
  - 자식 컴포넌트의 속성값으로 입력하면 객체 내용이 변경되지 않아도 자식 컴포넌트 입장에서는 속성값이 변경되었다고 인식한다.
  - 항상 같은 값을 가지고 있다면 컴퓨넌트 밖으로 빼서 상수로 관리하면 변하지 않는 값이 된다.
```jsx
<Select
  option={[
  {name: 'apple', price: 500},
  {name: 'banana', price: 500},
  {name: 'orange', price: 500}
  ]} // 내부에 입력
/>

const FRUIT = [
  {name: 'apple', price: 500},
  {name: 'banana', price: 500},
  {name: 'orange', price: 500}
]; // 외부에서 상수로 입력
```
- `filter`연산을 하게되면 랜더링 할 때 마다 새로운 값이 된다.
  - `useMemo` hook을 사용한다.
    - 안에서 사용하는 속성값이나 상태값을 의존성 배열에 입력하면 된다.
```jsx
<Seleect
  options={FRUITS.filter(item => item.price <= maxPrice)}
  // 랜더링 할 때 마다 새로운 값이 생성
/>

const fruits =  useMemo(() => 
  FRUITS.filer(item => item.price <= maxPrice
), [maxPrice]); // 필요할 때만 fruits 값이 변경되도록 할 수 있다.
// maxPrice 상태값을 사용했으므로 의존성 배열에 입력
// maxPrice가 변경될 때만 fruits가 변경
```

#### 성능
- 미리 성능을 걱정해서 `React.memo`, `useCallback`, `useMemo`같은 것을 사용하는 것을 추천하지 않는다.
- 성능 최적화하는 코드는 가독성이 좋지않고, 유지보수 비용이 증가한다.
- 성능 이슈 발생 시 해당하는 코드만 최적화하는 것을 추천한다.

### 값이 변경되지 않는 문제 발생
- 상태값 직접 수정하는 경우
  - 변경을 원하는 값의 레퍼런스가 변경되지않는다.
  - 상태값은 새로운 배열을 만들어서 변경해야한다.
  - 상태값은 불변 객체로 관리해야한다.
```jsx
const [frutis, setFruits] = useState(['apple', 'banana', 'orange']);
const [newFriut, setNewFriut] = useState('');
const addNewFruit = () => {
  fruits.push(newFruit); // 상태값 직접 수정
  setFruits([...frutis, newFruit]); // 새로운 배열읆 만들어서 변경해야한다.
  setNewFruit('');
}
```

### 돔 성능 최적화
- 요소의 타입을 변경하면 해당요소의 자식 요소도 모두 변경된다.
- 요소의 속성값만 변경할 경우 해당하는 속성만 변경이 된다.
 
#### 타입변경
- 자식 요소가 컴포넌트라면 해당 컴포넌트는 언마운트 되고 다시 마운트가 된다.
- 상태값도 초기화가 된다.
- 자식 요소가 돔 요소라면 실제 돔에서 자식 요소가 삭제되고 추가된다.
- 자식 요소가 많은 요소에 타입을 변경하면 화면이 끊기는 느낌이 들 수 있다.

#### 요소변경
- 해당하는 속성만 수정이 된다.
- 요소가 삭제되거나 추가되지는 않는다.
- 자식 컴포넌트도 영향이 없다.

#### 변화인지
- 일반적으로 새로운 요소를 추가하거나 삭제하면 해당 요소만 실제 돔에 추가 또는 삭제를 하고 기존 요소는 건드리지 않는다.
- 가상돔 비교를 통해서 변화된 곳을 인지한다.
- 중간에 요소가 추가되면 그 뒤 요소가 변경되지 않았다는 것을 알지 못한다.
  - 순서 정보를 이용해서 효율적인 랜더링을 한다.
  - `key` 속성값을 이용하면 추가되는 값만 인지가 가능하다.
  - 리액트가 랜더링을 효율적으로 할 수 있도록 제공하는 추가정보이다.
  - `id` 대신 `key` 속성 값을 입력하는 것이 좋다.
  -  `key`를 index로 입력하는 경우 추가/삭제/순서 변경의 경우 비효율적으로 랜더링된다.
    - 마지막 요소만 추가될 경우 외에는 적합하진 않다.